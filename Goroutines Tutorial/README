# Goroutines Tutorial - Complete Beginner's Guide

Welcome to the comprehensive Goroutines tutorial! This guide will take you from complete beginner to advanced user of Go's concurrency features.

---

## ðŸ“š Table of Contents

1. [What are Goroutines?](#what-are-goroutines)
2. [Why Use Goroutines?](#why-use-goroutines)
3. [Basic Concepts](#basic-concepts)
4. [Tutorial Structure](#tutorial-structure)
5. [Part 1: Basic Goroutines](#part-1-basic-goroutines)
6. [Part 2: Intermediate Patterns](#part-2-intermediate-patterns)
7. [Part 3: Advanced Patterns](#part-3-advanced-patterns)
8. [Common Pitfalls](#common-pitfalls)
9. [Best Practices](#best-practices)
10. [Practice Exercises](#practice-exercises)
11. [Further Reading](#further-reading)

---

## What are Goroutines?

**Goroutines** are lightweight threads managed by the Go runtime. They are one of the most powerful features of Go, enabling easy concurrent programming.

### Key Characteristics:

- **Lightweight**: Start with only ~2KB of stack space (vs ~1MB for OS threads)
- **Efficient**: Managed by Go runtime, not the OS
- **Scalable**: Can run millions of goroutines on a single machine
- **Simple**: Just add `go` before a function call!

### Goroutine vs Thread:

| Feature | Goroutine | OS Thread |
|---------|-----------|-----------|
| Stack Size | ~2KB (grows/shrinks) | ~1MB (fixed) |
| Creation Time | Microseconds | Milliseconds |
| Management | Go runtime | Operating System |
| Max Count | Millions | Thousands |
| Context Switch | Faster | Slower |

---

## Why Use Goroutines?

### Real-World Use Cases:

1. **Web Servers**: Handle thousands of concurrent requests
2. **Data Processing**: Process multiple files/records in parallel
3. **I/O Operations**: Make multiple API calls simultaneously
4. **Background Tasks**: Run cleanup, monitoring, or logging tasks
5. **Microservices**: Concurrent service communication

### Example Performance Gain:

```
Sequential Processing:     5 tasks Ã— 1 second each = 5 seconds
Concurrent (Goroutines):   5 tasks running parallel = ~1 second
```

---

## Basic Concepts

### 1. Starting a Goroutine

```go
// Normal function call (synchronous)
doSomething()

// Goroutine (asynchronous)
go doSomething()
```

### 2. Channels - Communication Between Goroutines

```go
ch := make(chan int)    // Create channel
ch <- 42                // Send to channel
value := <-ch           // Receive from channel
```

### 3. WaitGroup - Waiting for Goroutines

```go
var wg sync.WaitGroup
wg.Add(1)        // Increment counter
go func() {
    defer wg.Done()  // Decrement when done
    // Do work...
}()
wg.Wait()        // Wait until counter is 0
```

---

## Tutorial Structure

This tutorial includes **3 example files** with **increasing complexity**:

```
Goroutines/
â”œâ”€â”€ 01_basic_goroutine.go       â† Start here!
â”œâ”€â”€ 02_intermediate_goroutine.go
â”œâ”€â”€ 03_advanced_goroutine.go
â”œâ”€â”€ exercises.go                 â† Practice problems
â”œâ”€â”€ solutions.go                 â† Solutions to exercises
â””â”€â”€ README                       â† You are here
```

### How to Use This Tutorial:

1. **Read** the theory in this README
2. **Run** the example files in order
3. **Modify** the examples to experiment
4. **Complete** the exercises
5. **Review** the solutions

---

## Part 1: Basic Goroutines

**File**: `01_basic_goroutine.go`

### Topics Covered:

#### 1.1 Launching a Goroutine

The simplest goroutine:

```go
func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    go sayHello()  // Launch goroutine
    time.Sleep(time.Second)  // Wait for it
}
```

**âš ï¸ Important**: Main function won't wait for goroutines automatically!

#### 1.2 Multiple Goroutines

```go
go task1()
go task2()
go task3()
// All run concurrently!
```

#### 1.3 Anonymous Functions

```go
go func() {
    fmt.Println("Anonymous goroutine!")
}()
```

#### 1.4 Passing Arguments

```go
go greet("Alice", 100*time.Millisecond)
```

#### 1.5 Loop Variable Pitfall âš ï¸

**WRONG**:
```go
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // All print same value!
    }()
}
```

**CORRECT**:
```go
for i := 0; i < 5; i++ {
    go func(n int) {
        fmt.Println(n)  // Pass as argument
    }(i)
}
```

### Running Basic Examples:

```bash
cd Goroutines
go run 01_basic_goroutine.go
```

**Expected Output**: You'll see concurrent execution with interleaved output.

---

## Part 2: Intermediate Patterns

**File**: `02_intermediate_goroutine.go`

### Topics Covered:

#### 2.1 WaitGroup - Proper Synchronization

```go
var wg sync.WaitGroup

for i := 1; i <= 5; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        // Do work...
    }(i)
}

wg.Wait()  // Wait for all goroutines
```

**Why use WaitGroup?**
- No need for arbitrary `time.Sleep()`
- Main function waits for all goroutines to complete
- More reliable and professional

#### 2.2 Channels - Type-Safe Communication

**Unbuffered Channel**:
```go
ch := make(chan string)
go func() { ch <- "hello" }()
msg := <-ch  // Blocks until data arrives
```

**Buffered Channel**:
```go
ch := make(chan int, 3)  // Can hold 3 values
ch <- 1  // Doesn't block
ch <- 2
ch <- 3
```

#### 2.3 Channel Direction

```go
func send(ch chan<- int) {    // Send-only
    ch <- 42
}

func receive(ch <-chan int) { // Receive-only
    value := <-ch
}
```

**Benefits**: Type safety, clearer intent

#### 2.4 Closing Channels

```go
ch := make(chan int)

go func() {
    for i := 1; i <= 5; i++ {
        ch <- i
    }
    close(ch)  // Signal: no more data
}()

for num := range ch {  // Loop until closed
    fmt.Println(num)
}
```

**Rules**:
- Only sender should close
- Closing is optional (for signaling)
- Receiving from closed channel returns zero value

#### 2.5 Select Statement - Multiplexing

```go
select {
case msg1 := <-ch1:
    fmt.Println("From ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("From ch2:", msg2)
case <-time.After(1 * time.Second):
    fmt.Println("Timeout!")
default:
    fmt.Println("No channel ready")
}
```

**Use Cases**:
- Handle multiple channels
- Implement timeouts
- Non-blocking operations

### Running Intermediate Examples:

```bash
go run 02_intermediate_goroutine.go
```

---

## Part 3: Advanced Patterns

**File**: `03_advanced_goroutine.go`

### Topics Covered:

#### 3.1 Worker Pool Pattern

**Problem**: Process many jobs with limited workers

```go
jobs := make(chan Job, 100)
results := make(chan Result, 100)

// Start fixed number of workers
for w := 1; w <= numWorkers; w++ {
    go worker(w, jobs, results)
}

// Send jobs
for j := 1; j <= numJobs; j++ {
    jobs <- Job{ID: j}
}
close(jobs)
```

**Benefits**:
- Control resource usage
- Better performance than unlimited goroutines
- Common in production systems

#### 3.2 Fan-Out / Fan-In Pattern

**Fan-Out**: Multiple goroutines read from same channel
**Fan-In**: Multiple goroutines send to same channel

```go
// One producer, multiple workers (fan-out)
input := make(chan int)
go producer(input)

for w := 1; w <= 3; w++ {
    go worker(w, input, output)
}

// Multiple workers, one collector (fan-in)
```

#### 3.3 Context for Cancellation

**Problem**: How to stop all goroutines gracefully?

```go
ctx, cancel := context.WithCancel(context.Background())

go worker(ctx)

// Later...
cancel()  // All workers receive signal
```

**Checking for Cancellation**:
```go
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return  // Stop working
        default:
            // Do work
        }
    }
}
```

#### 3.4 Context with Timeout

```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// All operations stop after 5 seconds
```

#### 3.5 Rate Limiting

**Control request rate**:

```go
ticker := time.NewTicker(200 * time.Millisecond)
defer ticker.Stop()

for req := range requests {
    <-ticker.C  // Wait for ticker
    process(req)
}
```

#### 3.6 Semaphore Pattern

**Limit concurrent goroutines**:

```go
sem := make(chan struct{}, maxConcurrent)

for i := 0; i < tasks; i++ {
    sem <- struct{}{}  // Acquire
    go func() {
        defer func() { <-sem }()  // Release
        // Do work
    }()
}
```

#### 3.7 Error Group Pattern

**Collect errors from multiple goroutines**:

```go
var eg ErrorGroup

eg.Go(func() error { return task1() })
eg.Go(func() error { return task2() })

errors := eg.Wait()
```

### Running Advanced Examples:

```bash
go run 03_advanced_goroutine.go
```

---

## Common Pitfalls

### âŒ Pitfall 1: Not Waiting for Goroutines

```go
func main() {
    go doSomething()
    // Program exits immediately!
}
```

**Solution**: Use `WaitGroup` or channels

### âŒ Pitfall 2: Loop Variable Capture

```go
for i := 0; i < 5; i++ {
    go func() {
        fmt.Println(i)  // All print 5!
    }()
}
```

**Solution**: Pass as argument

### âŒ Pitfall 3: Closing Channel from Receiver

```go
// WRONG
go func() {
    msg := <-ch
    close(ch)  // Receiver shouldn't close!
}()
```

**Solution**: Only sender closes

### âŒ Pitfall 4: Sending on Closed Channel

```go
close(ch)
ch <- 42  // Panic!
```

### âŒ Pitfall 5: Race Conditions

```go
counter := 0
for i := 0; i < 1000; i++ {
    go func() {
        counter++  // Race condition!
    }()
}
```

**Solution**: Use `sync.Mutex` or channels

### âŒ Pitfall 6: Deadlock

```go
ch := make(chan int)
ch <- 42  // Deadlock! No receiver
```

**Solution**: Use buffered channel or separate goroutine

---

## Best Practices

### âœ… 1. Use WaitGroups for Unknown Completion Time

```go
var wg sync.WaitGroup
for _, task := range tasks {
    wg.Add(1)
    go func(t Task) {
        defer wg.Done()
        process(t)
    }(task)
}
wg.Wait()
```

### âœ… 2. Always Use defer for Cleanup

```go
go func() {
    defer wg.Done()
    defer mu.Unlock()
    defer close(ch)
    // Work...
}()
```

### âœ… 3. Channel Direction for API Design

```go
func producer(out chan<- int) { /* send only */ }
func consumer(in <-chan int) { /* receive only */ }
```

### âœ… 4. Buffered Channels for Known Capacity

```go
results := make(chan Result, numWorkers)
```

### âœ… 5. Context for Cancellation

```go
func doWork(ctx context.Context) error {
    // Always accept context as first parameter
}
```

### âœ… 6. Use sync.Once for One-Time Initialization

```go
var once sync.Once
once.Do(func() {
    // Runs only once, even with multiple goroutines
})
```

### âœ… 7. Detect Race Conditions

```bash
go run -race program.go
```

### âœ… 8. Limit Goroutines in Production

Don't create unlimited goroutines - use worker pools!

---

## Practice Exercises

### Exercise 1: Parallel Web Scraper (Easy)

Create a program that fetches 5 URLs concurrently and prints results.

**Hints**:
- Use goroutines for each fetch
- Use WaitGroup to wait for all
- Use channels to collect results

### Exercise 2: Concurrent Counter (Medium)

Create a counter that can be safely incremented by multiple goroutines.

**Hints**:
- Use `sync.Mutex`
- Launch 100 goroutines
- Each increments counter 1000 times
- Verify final count is 100,000

### Exercise 3: Pipeline (Medium)

Build a 3-stage pipeline:
1. Generate numbers 1-100
2. Square them
3. Filter even numbers

**Hints**:
- Use 3 goroutines
- Connect with channels
- Each stage processes and passes to next

### Exercise 4: Timeout Handler (Hard)

Create a function that runs a task with a timeout. If task exceeds timeout, cancel it.

**Hints**:
- Use `context.WithTimeout`
- Use select statement
- Return error if timeout

### Exercise 5: Rate-Limited API Client (Hard)

Implement an API client that makes max 10 requests per second.

**Hints**:
- Use `time.Ticker`
- Queue requests in channel
- Workers respect rate limit

**Solutions available in**: `solutions.go`

---

## Quick Reference Card

### Creating Goroutines
```go
go func()           // Anonymous function
go myFunc()         // Named function
go myFunc(arg)      // With arguments
```

### Channels
```go
ch := make(chan T)        // Unbuffered
ch := make(chan T, 10)    // Buffered
ch <- value               // Send
value := <-ch             // Receive
close(ch)                 // Close
for v := range ch { }     // Loop until closed
```

### Synchronization
```go
var wg sync.WaitGroup
wg.Add(1)
wg.Done()
wg.Wait()

var mu sync.Mutex
mu.Lock()
mu.Unlock()
```

### Context
```go
ctx, cancel := context.WithCancel(context.Background())
ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
ctx, cancel := context.WithDeadline(ctx, time.Now().Add(5*time.Second))
<-ctx.Done()
```

### Select
```go
select {
case v := <-ch1:
case ch2 <- value:
case <-time.After(1*time.Second):
default:
}
```

---

## Common Patterns Summary

| Pattern | Use Case | Key Components |
|---------|----------|----------------|
| Worker Pool | Limited workers, many jobs | WaitGroup, Channels |
| Fan-Out/Fan-In | Parallel processing | Multiple goroutines, Channels |
| Pipeline | Multi-stage processing | Connected channels |
| Timeout | Time-limited operations | Context, Select |
| Rate Limiting | Control request rate | Ticker, Channels |
| Semaphore | Limit concurrency | Buffered channel |
| Done Channel | Signal completion | Close channel |

---

## Debugging Tips

### 1. Detect Race Conditions
```bash
go run -race yourprogram.go
go test -race ./...
```

### 2. Find Deadlocks

Go runtime detects deadlocks:
```
fatal error: all goroutines are asleep - deadlock!
```

### 3. Debug with Logging

```go
log.Printf("Goroutine %d: Starting\n", id)
```

### 4. Use pprof for Profiling

```go
import _ "net/http/pprof"
```

---

## Performance Tips

1. **Goroutines are cheap, but not free** - Don't create millions unnecessarily
2. **Use buffered channels** when you know capacity
3. **Worker pools** better than unlimited goroutines
4. **Avoid goroutine leaks** - ensure all goroutines can exit
5. **Context for long-running operations** - enable cancellation

---

## Further Reading

### Official Documentation
- [Effective Go - Concurrency](https://golang.org/doc/effective_go#concurrency)
- [Go Blog - Concurrency Patterns](https://blog.golang.org/pipelines)
- [Go by Example - Goroutines](https://gobyexample.com/goroutines)

### Books
- "Concurrency in Go" by Katherine Cox-Buday
- "The Go Programming Language" by Donovan & Kernighan

### Videos
- [Go Concurrency Patterns (Rob Pike)](https://www.youtube.com/watch?v=f6kdp27TYZs)
- [Advanced Go Concurrency Patterns](https://www.youtube.com/watch?v=QDDwwePbDtw)

### Practice
- [Tour of Go - Concurrency](https://tour.golang.org/concurrency/1)
- [Exercism - Go Track](https://exercism.org/tracks/go)

---

## Conclusion

Goroutines are one of Go's killer features! With practice, you'll find them:
- **Easy to use** - just add `go`
- **Powerful** - handle massive concurrency
- **Practical** - solve real-world problems

### Learning Path:
1. âœ… Master basics (goroutines, channels, waitgroups)
2. âœ… Learn patterns (worker pools, pipelines)
3. âœ… Use context for cancellation
4. âœ… Practice with real projects
5. âœ… Read production code

### Next Steps:
1. Run all 3 example files
2. Complete the exercises
3. Build a small concurrent project
4. Read "Effective Go"
5. Explore standard library patterns

---

**Happy Coding! ðŸš€**

Remember: *"Don't communicate by sharing memory; share memory by communicating."*

---

**Questions?** Check out:
- [Go Forum](https://forum.golangbridge.org/)
- [r/golang](https://reddit.com/r/golang)
- [Gophers Slack](https://gophers.slack.com/)
